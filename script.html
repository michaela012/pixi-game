<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Hello World</title>
</head>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/5.1.3/pixi.min.js"></script>
<body>
  <script type="text/javascript">
    let type = "WebGL"
    if(!PIXI.utils.isWebGLSupported()){
      type = "canvas"
    }

    PIXI.utils.sayHello(type)

  //Aliases
  let Loader = PIXI.Loader;
  let Sprite = PIXI.Sprite;


  //Create a Pixi Application
  let app = new PIXI.Application({ 
      width: 400, 
      height: 400,                       
      antialias: true, 
      transparent: false, 
      resolution: 1
    }
  );
  //Add the canvas that Pixi automatically created for you to the HTML document
  document.body.appendChild(app.view);

  //load spritesheets and run `setup` function
  Loader.shared
    .add("Spritesheets/playerSprites.json")
    .load(setup);

  //define vars
  let p1, p2, state, playerSprites, p1Textures, p2Textures;
  let p1Jumped = false;



  //handle keyboard input
  function keyboard(value){
    let key = {};
    key.value = value;
    key.isDown = false;
    key.isUp = true;
    key.press = undefined;
    key.release = undefined;

    //The `downHandler`
    key.downHandler = event => {
      if (event.key === key.value) {
        if (key.isUp && key.press) key.press();
        key.isDown = true;
        key.isUp = false;
        event.preventDefault();
      }
    };

    //The `upHandler`
    key.upHandler = event => {
      if (event.key === key.value) {
        if (key.isDown && key.release) key.release();
        key.isDown = false;
        key.isUp = true;
        event.preventDefault();
      }
    };

    //Attach event listeners
    const downListener = key.downHandler.bind(key);
    const upListener = key.upHandler.bind(key);
    
    window.addEventListener(
      "keydown", downListener, false
    );
    window.addEventListener(
      "keyup", upListener, false
    );
    
    // Detach event listeners
    key.unsubscribe = () => {
      window.removeEventListener("keydown", downListener);
      window.removeEventListener("keyup", upListener);
    };
    
    return key;
  }

  function hitTestRectangle(r1, r2) {
    //Define the variables we'll need to calculate
    let hit, combinedHalfWidths, combinedHalfHeights, vx, vy;

    //hit will determine whether there's a collision
    hit = false;

    //Find the center points of each sprite
    r1.centerX = r1.x + r1.width / 2;
    r1.centerY = r1.y + r1.height / 2;
    r2.centerX = r2.x + r2.width / 2;
    r2.centerY = r2.y + r2.height / 2;

    //Find the half-widths and half-heights of each sprite
    r1.halfWidth = r1.width / 2;
    r1.halfHeight = r1.height / 2;
    r2.halfWidth = r2.width / 2;
    r2.halfHeight = r2.height / 2;

    //Calculate the distance vector between the sprites
    vx = r1.centerX - r2.centerX;
    vy = r1.centerY - r2.centerY;

    //Figure out the combined half-widths and half-heights
    combinedHalfWidths = r1.halfWidth + r2.halfWidth;
    combinedHalfHeights = r1.halfHeight + r2.halfHeight;

    //Check for a collision on the x axis
    if (Math.abs(vx) < combinedHalfWidths) {

      //A collision might be occurring. Check for a collision on the y axis
      if (Math.abs(vy) < combinedHalfHeights) {

        //There's definitely a collision happening
        hit = true;
      } else {

        //There's no collision on the y axis
        hit = false;
      }
    } else {

      //There's no collision on the x axis
      hit = false;
    }

    //`hit` will be either `true` or `false`
    return hit;
  };


  //This `setup` function will run when the image has loaded
  function setup() {
    //load spritesheets
    //playerSprites = Loader.shared.resources["Spritesheets/playerSprites.json"].spritesheet.textures;
    let p1WalkTextures = [];
    let p2WalkTextures = [];

    let animations = {
      "p1_walk": ["p1_walk01.png","p1_walk02.png","p1_walk03.png","p1_walk04.png","p1_walk05.png","p1_walk06.png","p1_walk07.png","p1_walk08.png","p1_walk09.png","p1_walk10.png","p1_walk11.png"],
      "p2_walk": ["p2_walk01.png","p2_walk02.png","p2_walk03.png","p2_walk04.png","p2_walk05.png","p2_walk06.png","p2_walk07.png","p2_walk08.png","p2_walk09.png","p2_walk10.png","p2_walk11.png"]
    };

    for (i=0; i <= 10; i++){
      p1WalkTextures[i] = PIXI.Texture.from(animations.p1_walk[i]);
      p2WalkTextures[i] = PIXI.Texture.from(animations.p2_walk[i]);
    }

    p1Textures= {"walkTextures" : p1WalkTextures, 
      "duck": PIXI.Texture.from("p1_duck.png"), 
      "front": PIXI.Texture.from("p1_front.png"), 
      "hurt": PIXI.Texture.from("p1_hurt.png"), 
      "jump": PIXI.Texture.from("p1_jump.png"), 
      "stand": PIXI.Texture.from("p1_stand.png")};

    p2Textures= {"walkTextures" : p2WalkTextures, 
      "duck": PIXI.Texture.from("p2_duck.png"), 
      "front": PIXI.Texture.from("p2_front.png"), 
      "hurt": PIXI.Texture.from("p2_hurt.png"), 
      "jump": PIXI.Texture.from("p2_jump.png"), 
      "stand": PIXI.Texture.from("p2_stand.png")};
    


    //vars
    let spriteScale = 40;
    let spriteScaleHeight = spriteScale + (spriteScale*.2);

    //make sprites
    // p1
    p1 = new Sprite(p1Textures.front);
    p1.height = spriteScaleHeight;
    p1.width = spriteScale;
    p1.y = app.screen.height /1.5 - p1.height/2;
    p1.x=100;
    p1.vx = 0;
    p1.vy = 0;
    // p2
    p2 = new Sprite(p2Textures.front);
    p2.height = spriteScaleHeight;
    p2.width = spriteScale;
    p2.y = app.screen.height / 2 - p2.height/2;
    p2.x=100;
    p2.vx = 0;
    p2.vy = 0;

    //Add elements to stage
    app.stage.addChild(p1);
    app.stage.addChild(p2);
    

    //listen for keyboard input
    let left = keyboard("ArrowLeft"),
      right = keyboard("ArrowRight"),
      up = keyboard("ArrowUp"),
      down = keyboard("ArrowDown");
    
    //key press and release methods
    // left
    left.press = () => {
      p1.vx = -1;
      p1.height = spriteScaleHeight;
    }
    left.release = () => {
      p1.vx = 0;
      p1.texture = p1Textures.stand;
      p1.texture.rotate = 12;
    }

    //right
    right.press = () => {
      p1.vx = 1;
      p1.height = spriteScaleHeight;
    }
    right.release = () => {
      p1.vx = 0;
      p1.texture = p1Textures.stand;
      p1.texture.rotate = 0;
    }

    //up
    up.press = () => {
      p1.vy = -1;
      p1Jumped = true;
    }
    up.release = () => {
      p1.vy = 0;
      p1.texture = p1Textures.stand;
      p1Jumped = false;
    }

    //down
    down.press = () => {
      p1.vy = 0;
      p1.height = spriteScale;
      p1.texture = p1Textures.duck;
    }
    down.release = () => {
      p1.vy = 0;
      p1.height = spriteScaleHeight;
      p1.texture = p1WalkTextures[1];
    }


    //set game state
    state = play;
    //start game loop
    app.ticker.add(delta => gameLoop(delta));
  }


  function gameLoop(delta) {
    state(delta);
  }


  function play(delta){
    //Move player
    p1.x += p1.vx;
    p1.y += p1.vy;

    //test collision
    if (hitTestRectangle(p1, p2)){
      console.log("hit!");
    }

    //assign textures
    // up
    if (p1.vy === -1 && p1.vx === 0){
      p1.texture = p1Textures.jump;
    }
    //right
    if (p1.vx === 1){
      if (p1.vy === -1){    //if jumping
        p1.texture = p1Textures.jump;
        p1.texture.rotate = 0;
      }
      else {    //not jumping
        let cycle = Math.floor(Date.now() / 100) % 4;
        p1.texture = p1Textures.walkTextures[cycle];
        p1.texture.rotate = 0;
      }
    }
    // left
    else if (p1.vx === -1){
      if (p1.vy === -1){
        p1.texture = p1Textures.jump;
        p1.texture.rotate = 12;
      }
      else {
        let cycle = Math.floor(Date.now() / 100) % 4;
        p1.texture = p1Textures.walkTextures[cycle];
        p1.texture.rotate = 12;
      }
    }

  }

  


  </script>
</body>
</html>
