<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Hello World</title>
</head>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/5.1.3/pixi.min.js"></script>
<body>
  <script type="text/javascript">
    let type = "WebGL"
    if(!PIXI.utils.isWebGLSupported()){
      type = "canvas"
    }

    PIXI.utils.sayHello(type)

  //Aliases
  let Loader = PIXI.Loader;
  let Sprite = PIXI.Sprite;
  let Application = PIXI.Application;
  let Texture = PIXI.Texture;


  //Create a Pixi Application
  let app = new Application({ 
      width: 250,
      height: 500,
      antialias: true, 
      transparent: false, 
      resolution: 1
    }
  );
  //Add the canvas that Pixi automatically created for you to the HTML document
  document.body.appendChild(app.view);
  app.view.focus();

  //load spritesheets and run `setup` function
  Loader.shared
    .add("Spritesheets/playerSprites.json")
    .add("Spritesheets/tiles.json")
    .add("Spritesheets/items.json")
    .add("Spritesheets/backgrounds/bg.png")
    .load(setup);

  //define vars
  let p1, p2, ground, state, p1Textures, p2Textures, spriteScale;
  let left, right, up, down;
  let platforms = new Array();
  let coins = new Array();


  //handle keyboard input
  function keyboard(value){
    let key = {};
    key.value = value;
    key.isDown = false;
    key.isUp = true;
    key.press = undefined;
    key.release = undefined;

    //The `downHandler`
    key.downHandler = event => {
      if (event.key === key.value) {
        if (key.isUp && key.press) key.press();
        key.isDown = true;
        key.isUp = false;
        event.preventDefault();
      }
    };

    //The `upHandler`
    key.upHandler = event => {
      if (event.key === key.value) {
        if (key.isDown && key.release) key.release();
        key.isDown = false;
        key.isUp = true;
        event.preventDefault();
      }
    };

    //Attach event listeners
    const downListener = key.downHandler.bind(key);
    const upListener = key.upHandler.bind(key);

    key.subscribe = () => {
      window.addEventListener(
        "keydown", downListener, false
      );
      window.addEventListener(
        "keyup", upListener, true
      );
    }
    

    
    // Detach event listeners
    key.unsubscribe = () => {
      window.removeEventListener("keydown", downListener);
      window.removeEventListener("keyup", upListener);
    };
    
    return key;
  }

  function testCollision(r1, r2) {
    //Define the variables we'll need to calculate
    let hit, combinedHalfWidths, combinedHalfHeights, vx, vy;

    //hit will determine whether there's a collision
    hit = false;

    //Find the center points of each sprite
    r1.centerX = r1.x + r1.width / 2;
    r1.centerY = r1.y + r1.height / 2;
    r2.centerX = r2.x + r2.width / 2;
    r2.centerY = r2.y + r2.height / 2;

    //Find the half-widths and half-heights of each sprite
    r1.halfWidth = r1.width / 2;
    r1.halfHeight = r1.height / 2;
    r2.halfWidth = r2.width / 2;
    r2.halfHeight = r2.height / 2;

    //Calculate the distance vector between the sprites
    vx = r1.centerX - r2.centerX;
    vy = r1.centerY - r2.centerY;

    //Figure out the combined half-widths and half-heights
    combinedHalfWidths = r1.halfWidth + r2.halfWidth;
    combinedHalfHeights = r1.halfHeight + r2.halfHeight;

    //Check for a collision on the x axis
    if (Math.abs(vx) < combinedHalfWidths) {

      //A collision might be occurring. Check for a collision on the y axis
      if (Math.abs(vy) < combinedHalfHeights) {

        //There's definitely a collision happening
        hit = true;
      } else {

        //There's no collision on the y axis
        hit = false;
      }
    } else {

      //There's no collision on the x axis
      hit = false;
    }

    //`hit` will be either `true` or `false`
    return hit;
  };
  function testLanding(player, surface){
    let playerBottom = player.y + player.height*.5;

    if (testCollision(player, surface)){
      let surfaceTop = surface.y - surface.height*.5;

      if (playerBottom >= surfaceTop && playerBottom >= surfaceTop + 5){
        player.vy = 0;
        player.y = surfaceTop - player.height*.5;
        player.jumping = false;
        player.surfaceOn = surface;
        player.texture = p1Textures.stand;
        up.subscribe();
        down.subscribe();
      }
    }
    
  }
  function generatePlatform(texture){
    let prevPlatform = platforms[platforms.length-1];
    let size = Math.floor(Math.random() *3);
    for (let i=0; i<=size; i++) {
      let platform = new Sprite(texture);
      platform.height = spriteScale * .5;
      platform.width = spriteScale
      if (i == 0) {
        platform.y = prevPlatform.y - spriteScale - Math.random() * spriteScale * 2;
        platform.x = Math.random() * (app.screen.width - platform.width - 20) + 20;
      } else {
        platform.y = platforms[platforms.length - 1].y;
        platform.x = platforms[platforms.length - 1].x + spriteScale;
      }
      platform.vx = 0;
      platform.vy = prevPlatform.vy;
      platforms.push(platform);
      app.stage.addChild(platforms[platforms.length - 1]);
    }
  }

  //This `setup` function will run when the image has loaded
  function setup() {
    //load spritesheets
    //playerSprites = Loader.shared.resources["Spritesheets/playerSprites.json"].spritesheet.textures;
    let p1WalkTextures = [];
    let p2WalkTextures = [];

    let animations = {
      "p1_walk": ["p1_walk01.png","p1_walk02.png","p1_walk03.png","p1_walk04.png","p1_walk05.png","p1_walk06.png","p1_walk07.png","p1_walk08.png","p1_walk09.png","p1_walk10.png","p1_walk11.png"],
      "p2_walk": ["p2_walk01.png","p2_walk02.png","p2_walk03.png","p2_walk04.png","p2_walk05.png","p2_walk06.png","p2_walk07.png","p2_walk08.png","p2_walk09.png","p2_walk10.png","p2_walk11.png"]
    };

    for (i=0; i <= 10; i++){
      p1WalkTextures[i] = Texture.from(animations.p1_walk[i]);
      p2WalkTextures[i] = Texture.from(animations.p2_walk[i]);
    }

    p1Textures= {"walkTextures" : p1WalkTextures, 
      "duck": Texture.from("p1_duck.png"), 
      "front": Texture.from("p1_front.png"), 
      "hurt": Texture.from("p1_hurt.png"), 
      "jump": Texture.from("p1_jump.png"), 
      "stand": Texture.from("p1_stand.png")};

    p2Textures= {"walkTextures" : p2WalkTextures, 
      "duck": Texture.from("p2_duck.png"), 
      "front": Texture.from("p2_front.png"), 
      "hurt": Texture.from("p2_hurt.png"), 
      "jump": Texture.from("p2_jump.png"), 
      "stand": Texture.from("p2_stand.png")};
    

    //vars
    spriteScale = 20;
    let spriteScaleHeight = spriteScale + (spriteScale*.2);

    //make sprites
    // p1
    p1 = new Sprite(p1Textures.front);
    p1.height = spriteScaleHeight;
    p1.width = spriteScale;
    p1.y = app.screen.height /1.5 - p1.height/2;
    p1.x=100;
    p1._zIndex = 100000
    p1.vx = 0;
    p1.vy = 0;
    p1.surfaceOn = null;
    p1.jumped = false;
    p1.jumpHeight = null;
    p1.top = p1.y - p1.height*.5;
    p1.bottom = p1.y + p1.height*.5;
    p1.left = p1.x - p1.width*.5;
    p1.right = p1.x + p1.width*.5;


    //make containers  
    ground = new PIXI.Container();
    ground.vy = .1;
    for (i = 0; i < app.screen.width / spriteScale + 1; i++){
      grass = new Sprite(Texture.from("grassMid.png"));
      dirt = new Sprite(Texture.from("grassCenter.png"));
      grass.height = grass.width = dirt.height = dirt.width = spriteScale;
      dirt.y = ground.y + spriteScale-1;
      grass.x = dirt.x = i * spriteScale;
      ground.addChild(grass, dirt);
    }
    ground.y = app.screen.height - spriteScale*1.5;

    let bg = new Sprite(Loader.shared.resources["Spritesheets/backgrounds/bg.png"].texture);
    bg.height = bg.width = 1000;

    // platforms
    let dirtTexture = Texture.from("grassHalf.png");

   //create starting platforms
    let prevY = ground.y - spriteScaleHeight;
    while (prevY > 0){
      let size = Math.floor(Math.random() *3);
      for (let i=0; i<=size; i++){
        let platform = new Sprite(dirtTexture);
        platform.height = spriteScale*.5;
        platform.width = spriteScale
        if (i == 0){
          platform.y = prevY - spriteScale - Math.random()*spriteScale*2;
          platform.x= Math.random() * (app.screen.width - platform.width - 20) + 20;
        }
        else{
          platform.y = platforms[platforms.length-1].y;
          platform.x = platforms[platforms.length-1].x + spriteScale;
        }
        platform.vx = 0;
        platform.vy = .1;
        platforms.push(platform);
        prevY = platform.y;
      }
    }


    //coins
    let coinTexture = Texture.from("coinGold.png");
    let coinYBound = app.screen.height-10;
    let coinXBound = app.screen.width-10;
    let numCoins = 0;
    while (numCoins < 100){
      let valid = true;
      let coin = new Sprite(coinTexture);
      coin.x = Math.floor(Math.random() * (coinXBound + 5));
      coin.y = Math.floor(Math.random() * (coinYBound - 5));
      coin.height = coin.width = spriteScale*.5;

      for (let num in coins){
        if (testCollision(coin, coins[num])){
          valid = false;
          break;
        }
      }
      if (valid) {
        coins.push(coin);
        numCoins += 1;
      }
    }


    
    //Add elements to stage
    app.stage.addChild(bg);
    app.stage.addChild(ground);
    for (i in platforms){
      app.stage.addChild(platforms[i]);
    }
    for (i in coins){
      app.stage.addChild(coins[i]);
    }
    app.stage.addChild(p1);
    

    //listen for keyboard input
    left = keyboard("ArrowLeft"),
    right = keyboard("ArrowRight"),
    up = keyboard("ArrowUp"),
    down = keyboard("ArrowDown");

    //start listening for keyboard input
    left.subscribe();
    right.subscribe();
    down.subscribe();
    up.subscribe();
    

    //key press and release methods
    // left
    left.press = () => {
      p1.vx = -4;
      p1.height = spriteScaleHeight;
    }
    left.release = () => {
      p1.vx = 0;
      p1.texture = p1Textures.stand;
      p1.texture.rotate = 12;
    }

    //right
    right.press = () => {
      p1.vx = 4;
      p1.height = spriteScaleHeight;
    }
    right.release = () => {
      p1.vx = 0;
      p1.texture = p1Textures.stand;
      p1.texture.rotate = 0;
    }

    //up
    up.press = () => {
      p1.vy = -9;
      p1.jumping = true;
      p1.jumpHeight = p1.y - 3*spriteScale;
      p1.hangtime = 12;
      up.unsubscribe();
      down.unsubscribe();

    }

    //down
    down.press = () => {
      p1.vy = 0;
      p1.vx = 0;
      p1.y = p1.y + spriteScale * .15;
      p1.height = spriteScale * .9;
      p1.texture = p1Textures.duck;
      left.unsubscribe();
      right.unsubscribe();
      up.unsubscribe();
    }
    down.release = () => {
      p1.vy = 0;
      p1.y = p1.y - spriteScale * .15;
      p1.height = spriteScaleHeight;
      p1.texture = p1WalkTextures[1];
      left.subscribe();
      right.subscribe();
      up.subscribe();
    }


    //set game state
    state = play;
    //start game loop
    app.ticker.add(delta => gameLoop(delta));
  }


  function gameLoop(delta) {
    state(delta);
  }


  function play(delta){
    /*//check collision and render coins
    for (let i in coins){
      if (testCollision(p1, coins[i])){
        app.stage.removeChild(coins[i]);
        //coins.splice(i, 1);
      }
    }*/

    //generate platforms
    if (platforms[platforms.length-1].y >= 0){
      generatePlatform(Texture.from("grassHalf.png"));
    }

    //move ground if necessary
    if (ground.y < app.screen.height + spriteScale*10){
        ground.y += ground.vy
    }

    //determine platform speed
    let speed = p1.vy;
    if (p1.y < app.screen.height * .1) speed = 1;
    else if (p1.y < app.screen.height * .2) speed = .9;
    else if (p1.y < app.screen.height * .3) speed = .8;
    else if (p1.y < app.screen.height * .4) speed = .7;
    else if (p1.y < app.screen.height * .5) speed = .6;
    else if (p1.y < app.screen.height * .6) speed = .5;
    else if (p1.y < app.screen.height * .7) speed = .4;
    else speed = .3;


    //move platforms, remove non-visible platforms
    let num = 0;
    while (num != platforms.length){
      platforms[num].vy = speed;
      platforms[num].y += platforms[num].vy;
      if (platforms[num].y > app.screen.height*1.1){
        platforms.splice(num, 1);
      }
      else{
        num++;
      }
    }
    //Move player
    p1.x += p1.vx;
    p1.y += p1.vy;

    //screen wrap (player going off right appears on left, vice versa)
    if (p1.x >= app.screen.width){
      p1.x = 0;
    }
    else if (p1.x <= 0){
      p1.x = app.screen.width;
    }


    for (let i in platforms){
          let surface = platforms[i];
          //testLanding(p1, surface);
        }


    //jumping
    if (p1.vy !== 0){
      p1.texture = p1Textures.jump;
      if (p1.vx < 0){   //moving left
        p1.texture.rotate = 12;
      }
      else {
        p1.texture.rotate = 0;
      }
    }
    //walking
    else if (p1.vx !== 0){ 
      let cycle = Math.floor(Date.now() / 100) % 4;
      p1.texture = p1Textures.walkTextures[cycle];
      //right
      if (p1.vx > 0){
        p1.texture.rotate = 0;
      }
      //left
      else { 
        p1.texture.rotate = 12;
      }
        
    }

    let playerBottom = p1.y + p1.height*.5;

    if (p1.jumping){
      if (p1.y <= p1.jumpHeight){
        if (p1.hangtime === 0){
          p1.jumpHeight = null;
          p1.vy = 8;
        }
        else{
          p1.hangtime -= 1;
          if (p1.hangtime >= 6){
            p1.vy = -1;
          }
          else{
            p1.vy = 1;
          }
        } 
      }
      //test for collisions
      else if (playerBottom >= ground.y){
        p1.vy = 0;
        p1.jumping = false;
        p1.surfaceOn = ground;
        p1.y = ground.y - spriteScale*1.1;
        p1.texture = p1Textures.stand;
        up.subscribe();
        down.subscribe();
      }
      else if (p1.vy > 0){
        for (let i in platforms){
          let surface = platforms[i];
          testLanding(p1, surface);
        }
      }
    }

    //han
    else if (p1.surfaceOn !== null){
      //player must be on a surface, or just leaving (falling)
      p1.y += speed;
      if ((playerBottom < ground.y-11) && (!testCollision(p1, p1.surfaceOn))){ //player not touching ground, or no longer touching the current surface
        p1.surfaceOn = null;
        p1.jumping = true;
        p1.texture = p1Textures.jump;
        p1.jumpHeight = p1.y;
        up.unsubscribe();
        down.unsubscribe();
      }
    }

    //end game sequence
    if (playerBottom >= app.screen.height+spriteScale/2) {
      app.stage.removeChildren();
      app.stage.addChild(new PIXI.Text("Game Over!", {fontSize: 18, fill: 0xe6eefc, align:'middle'}))
    }
  }


  


  </script>
</body>
</html>
